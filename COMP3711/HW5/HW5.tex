\documentclass{report}

\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocodex}
\usepackage{amsmath, amsfonts, amsthm}
\usepackage[scale = 0.8]{geometry}
\def\pr{\prime}
\begin{document}
    \section*{Problem 1}
    \subsection*{Discription}
    A modification could be adding a new array $S[n]$ for the number of shortest paths 
    from $s$ to vertex $n$, and an array $D[n]$ for length of the shortest path from 
    $s$ to vertex $n$. Obviously $S[n]$ is our answer. We initially set 
    \begin{align*}
        S[s] &= 1 \\
        S[n \neq s] &= 0 \\
        D[s] &= 0 \\
        D[n \neq s] &= \infty
    \end{align*}
    In each iteration of original BFS, we will extract $u$ from the queue, and find
    all its neighbours $v$. We will discard the test of whether $v$ has been visited
    or not, since it is embedded in the folloeing test.
    We will compare $D[u]+1$ and $D[v]$. If $D[u] + 1 < D[v]$, we will do 
    $D[v] \gets D[u] + 1, S[v] = 1$ and put $v$ into queue. 
    If $D[u]+1 = D[v]$, then we will do $S[v] \gets S[v] + 1$, however,
    we will not put $v$ into queue. If $D[u] + 1 > D[v]$, then we do nothing.

    \subsection*{Pseudocode}
    \begin{algorithm}
        \caption{Modified BFS}
        \begin{algorithmic}[1]
            \State{Initialize $D$ and $S$ as stated before}
            \State{Initialize an empty queue $Q$}
            \State{\textproc{Enqueue} ($Q, s$)}
            \While{$Q \neq \phi$}
                \State{$u \gets$ \textproc{Dequeue} ($Q$)} 
                \For{$v \in Adj[u]$}
                    \If{$D[u] + 1 < D[v]$} \Comment{Need to add $v$ into queue}
                        \State{$D[v] \gets D[u] + 1$}
                        \State{$S[v] \gets 1$}
                        \State{\textproc{Enqueue} ($Q, v$)}
                    \ElsIf{$D[u] + 1 = D[v]$} \Comment{Another path to $v$ exists}
                        \State{$S[v] \gets S[v] + 1$}
                    \EndIf{}
                \EndFor{}
            \EndWhile{}
            \Return{$S$}
        \end{algorithmic}
    \end{algorithm}

    \section*{Problem 2}
    \subsection*{Discription}
    During each iteration of topological sorting, there are possibly many vertexs with 
    in-degree zero. The original algorithm gives not specification on which to select. 
    We claim that by greedily selecting the smallest available index at each itereation 
    respectively, one can achieve a minimum lexicographic ordering at the end.
    The modification will be replacing the queue in topological sorting with a min-heap. 
    \newpage
    \subsection*{Pseudocode}
    \begin{algorithm}
        \caption{Modified topological sorting}
        \begin{algorithmic}[1]
            \State{Initialize H to be an empty heap}
            \For{u in V}
                \If{in-degree[u] = 0}
                    \State{add u to H}
                \EndIf{}
            \EndFor{}
            \While{H is non-empty}
                \State{u = H.top, H.pop}
                \State{Outpur u}
                \For{v in Adj[u]}
                    \State{in-degree[v] = in-degree[v]-1}
                    \If{in-degree[v] = 0}
                        \State{add v to H}
                    \EndIf{}
                \EndFor{}
            \EndWhile{}
        \end{algorithmic}
    \end{algorithm}

    \section*{Problem 3}
    \begin{proof}
    The only terminating exit of the algorithm is the step four. The termination condition
    is that the maximum connected component $C_k$ of $T - \{v\}$ have size not greater 
    than $|V| / 2$. It means that every connected components of $T - \{v\}$ have size 
    not greater thant $|V| / 2$. Therefore, when the algorithm terminates, it yields the 
    centroid.

    Now we will prove that the algorithm will terminate. We prove it by contradiction. 
    Suppose it does not terminate. Let $\{v_n\} = v_1, v_2, \ldots$ be an infinite 
    sequence of $v's$ generated in the step 5 of the algorithm. However, the total 
    amount of vertexs on the tree is finite, which indicates that there are repetitions
    in $\{v_n\}$. Without lost of generality, let $s = v_i = v_j$ for an $i < j$. 

    We have $i \neq j - 1$. This is obvious since the algorithm forces to find a neighbor 
    of current poing $v$, thus any adjacent points in $\{v_n\}$ are not the same. Hence 
    $v_i, v_{i+1}, \ldots, v_j$ formed a path on a tree from $s$ to itself. Since there 
    are no loop in a tree, $v_{i+1} = v_{j-1}$. Let $t = v_{i+1}$, and thus we have two
    movements: from $s$ to $t$, and $t$ to $s$.

    Split the tree by removing the edge $(s, t)$, we get two connected components:
    $C_s$, $C_t$. The movement from $s$ to $t$ indicates $|C_t| > |V| / 2$, and the 
    movement from $t$ to $s$ indicates $|C_s| > |V| / 2$. Therefore, $|C_s| + |C_t| > |V|$,
    but $|C_s| + |C_t| = |V|$ obviously and this incurs contradiction.
    \end{proof}
\end{document}